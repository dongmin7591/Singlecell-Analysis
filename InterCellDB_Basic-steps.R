# InterCellDB

#1.remove the 'GO.db' package.
remove.packages("GO.db")

#2.install the required packages and re-install 'GO.db' package from Bioconductor
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install("GO.db")

#3. install the InterCellDB package from GitHub

devtools::install_github("ZJUDBlab/InterCellDB")
install.packages("SeuratObject")
library(GO.db)
library(InterCellDB)  
library(Seurat)      
library(dplyr)        
library(future)      
library(MAST)

#Step 1: Data preparation and create InterCell object.

#>InterCellDB requires 2 data as input:
#>normalized count matrix
#>differentially expressed genes (DEGs) with their belonging clusters

seurat.obj <- readRDS("./Final.seurat.integrated.rds")

seurat.obj.all <- SplitObject(seurat.obj, split.by = 'Group')

seurat.obj<- seurat.obj.all[[2]]
Idents(seurat.obj)<-seurat.obj$singler_labels


all.markers <- FindAllMarkers(seurat.obj, only.pos = TRUE, min.pct = 0.1, logfc.threshold = 0.3,test.use = "MAST")
all.markers<-all.markers[all.markers$PVal <0.05 & all.markers$pct.1 > 0.2 & all.markers$LogFC> abs(0.5),]
#all.markers %>% group_by(cluster) %>% top_n(n=15, wt=avg_log2FC) -> top15
colnames(all.markers)[2] <- "LogFC"
colnames(all.markers)[5] <- "PVal"
head(all.markers)


tmp.counts <- seurat.obj[["RNA"]]@data
colnames(tmp.counts) <- as.character(Idents(seurat.obj))
tmp.counts[10:20, 10:20]

inter.obj <- CreateInterCellObject(all.markers, species = "human", add.exprs = TRUE, exprs.data = tmp.counts)


#2.Step 2: Customize interactions and proteins from databases

inter.obj <- SelectDBSubset(inter.obj,
                            use.exp = TRUE,   # to use experimentally validated interactions
                            exp.score.range = c(1, 1000),  # use all credibility score for 'use.exp'
                            use.know = TRUE,  # to use pathway curated interactions
                            know.score.range = c(1, 1000),  # use all credibility score for 'use.know'
                            use.pred = TRUE,  # to use predicted interactions
                            pred.score.range = c(1, 1000),  # use all credibility score for 'use.pred' 
                            sel.action.mode = "binding",  # select physically associated ones
                            sel.action.effect = "ALL")    # not limiting action effects


# fetch genes of interest. GO.db version is v3.8.2 here, different version may have non-identical result.
genes.receiver <- FetchGeneOI(inter.obj, 
                              sel.location = "Plasma Membrane",  # fetch proteins located in plasma membrane
                              sel.location.score = c(4:5),       # 4 and 5 are of high confidence
                              sel.type = "Receptor",             # fetch those receptors
                              sel.go.terms = "GO:0006955"        # fetch [GO:0006955]immune response related proteins, [GO:0006954] inflammatory response,0002544 
)

genes.sender <- FetchGeneOI(inter.obj, 
                            sel.location = "Extracellular Region",  # fetch proteins located in extracellular region
                            sel.location.score = c(4:5),            # 4 and 5 are of high confidence
                            sel.go.terms = "GO:0006955"             # fetch [GO:0006955]immune response related proteins
)

#Step 3: Perform full network analysis.

#>Full network analysis goes with 2 steps:
#> 1. generate cell label permutation list.
#> 2. network analysis and filter statistically significant gene pairs.
options(future.globals.maxSize=1024^2 * 8000)
plan("multiprocess", workers = 8)  # package future provides the parallel interface, here create 2 parallel processes  
# using options(future.globals.maxSize=1024^2 * 1000) to get more space to run parallel process
tmp.permlist <- Tool.GenPermutation(inter.obj, tmp.counts, perm.times = 100,p.seed = 101)
plan("sequential")  # close the parallel processes


plan("multiprocess", workers = 8)
inter.obj <- AnalyzeInterInFullView(inter.obj, 
                                    sel.some.genes.X = genes.receiver,  # set the genes for receiver cells
                                    sel.some.genes.Y = genes.sender,    # set the genes for sender cells
                                    sel.exprs.change = "Xup.Yup",       # select genes up-regulated for both sender cells and receiver cells
                                    run.permutation = TRUE,             # run statistical test with permutation list
                                    perm.expression = tmp.permlist,     # given the permutation list, generated by `Tool.GenPermutation`
                                    perm.pval.sides = "one-side-large", # use one-tailed test
                                    perm.pval.cutoff = 0.05)            # p-value cutoff 0.05
plan("sequential")



#torm.LN.clusters <- c("LN T cell", "Endo lymphatic", "Endo LN", "Fibroblast LN")
all.clusters <- ListAllClusters(inter.obj)                # list all clusters
#used.clusters <- setdiff(all.clusters, torm.LN.clusters)  # select those clusters in tumor(excludes torm.LN.clusters)
used.clusters <- all.clusters[order(all.clusters)]
# show the result of full network analysis
fullview.result <- GetResultFullView(inter.obj, 
                                     show.clusters.in.x = used.clusters,
                                     show.clusters.in.y = used.clusters,
                                     plot.axis.x.name = "signal receiving cells",
                                     plot.axis.y.name = "signal sending cells",
                                     nodes.size.range = c(1,8))
Tool.ShowGraph(fullview.result)  # visualization
Tool.WriteTables(fullview.result, dir.path = "./InterCellDB/OLP/GO:0006955/")  # write result into csv file

png("./InterCellDB/OLP/GO:0006955/fullview.result.png",width=4000,height=4000,res=500)
dev.off()
#Step 4: Perform intercellular analysis.


#Intercellular analysis focuses on one cell-cell interaction, and explores the results in 4 aspects:
#1.summarize action mode and action effect
#2.subset and rank gene pairs
#3.evaluate the specificity of gene pairs
#4.summarize gene pairs in spatial pattern
table(all.markers$cluster)
inter.obj <- FetchInterOI(inter.obj, cluster.x = "Terminal effector CD4 T cells", cluster.y = "Myeloid dendritic cells")
inter.obj <- AnalyzeInterInAction(inter.obj)
used.action.mode <- c("activation", "inhibition", "catalysis", "reaction", "expression", "ptmod")  # action mode: not showing mode 'binding' and 'other'
used.color.mode <- c("#FB8072", "#80B1D3", "#8DD3C7", "#FFFFB3", "#BEBADA", "#FDB462")  # customized color, one-to-one corresponding to those in `used.action.mode`
action.mode.result <- GetResultPieActionMode(inter.obj, 
                                             limits.exprs.change = c("Xup.Yup"),
                                             limits.action.mode = used.action.mode,
                                             color.action.mode = used.color.mode)
Tool.ShowGraph(action.mode.result)

action.effect.result <- GetResultPieActionEffect(inter.obj, limits.exprs.change = c("Xup.Yup"))
Tool.ShowGraph(action.effect.result)

inter.obj <- SelectInterSubset(inter.obj, 
                               sel.action.mode = "ALL",
                               sel.action.effect = "ALL",
                               sel.action.merge.option = "union"
)

result.inter.pairs <- GetResultTgCrosstalk(inter.obj, 
                                           func.to.use = list(
                                             Power = function(x) { log1p(x) },        # further log-transform the power
                                             Confidence = function(x) { 1/(1+x) }     # invert the confidence to show
                                           ),  
                                           axis.order.xy = c("Power", "Power"),       # order genes by power
                                           axis.order.xy.decreasing = c(TRUE, TRUE),  # select if ordering is decreasing
                                           nodes.size.range = c(1, 8))
Tool.ShowGraph(result.inter.pairs)



inter.obj <- SelectInterSubset(inter.obj, 
                               sel.some.genes.X = c("CD30","CD3G"),
                               sel.some.genes.Y = c("HLA-DRA","HLA-DRB1","HLA-DRB5","ACTR2")
                               
)


tmp.target.cluster.groups <- ListClusterGroups(inter.obj, 
                                               use.former = TRUE,
                                               cluster.former = c("Terminal effector CD4 T cells")  # list all crosstalk with Myeloid as receiver cell, this order is aligned with the X and Y axis in fullview result. In this example, clusters listed in X axis are the receiver cells.
)
#tmp.target.cluster.groups <- setdiff(tmp.target.cluster.groups, c("Myeloid~Myeloid", "Myeloid~Endo LN", "Myeloid~Endo lymphatic", "Myeloid~Fibroblast LN", "Myeloid~LN T cell"))

inter.obj <- AnalyzeInterSpecificity(inter.obj, 
                                     to.cmp.cluster.groups = tmp.target.cluster.groups
)

result.specificity <- GetResultTgSpecificity(inter.obj,
                                             sel.uq.cnt.options = seq_along(tmp.target.cluster.groups),
                                             plot.uq.cnt.merged = TRUE, 
                                             plot.name.X.to.Y = FALSE,
                                             func.to.use = list(Power = function(x) { log1p(x) },
                                                                Confidence = function(x) { 1/(1+x) }),
                                             dot.size.range = c(2,8),
                                             dot.colour.seq = c("#00809D", "#EEEEEE", "#C30000"),
                                             dot.colour.value.seq = c(0, 0.4, 1)
)
Tool.ShowGraph(result.specificity)



tmp.hide.locations <- setdiff(ListAllGeneLocation(inter.obj), c("Plasma Membrane", "Extracellular Region"))  # select the subcellular locations allowed to show
set.seed(101L)  # set seed to make reproducible result, or gene will be re-arranged every time re-running GetResultTgCellPlot
result.sptialpattern <- GetResultTgCellPlot(inter.obj, 
                                            area.extend.times = 20,  # control the size of plotting. Increase the value by 10 when warnings ask to
                                            hide.other.area = TRUE,
                                            hide.locations.X = tmp.hide.locations,
                                            hide.locations.Y = tmp.hide.locations,
                                            expand.gap.radius.list = list(ECM = 8, CTP = 2, NC = 2, OTHER = 2),
                                            link.size = 0.3,
                                            link.alpha = 0.8,
                                            legend.manual.left.spacing = grid::unit(0.1, "cm"),
                                            legend.manual.internal.spacing = unit(2, "cm")
)

Tool.ShowGraph(result.sptialpattern)



Sys.setenv( `_R_CHECK_LENGTH_1_CONDITION_` = "true")

